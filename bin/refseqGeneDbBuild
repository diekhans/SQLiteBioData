#!/usr/bin/env python3

import sys
from os import path as osp
import argparse
from datetime import datetime
from pycbio.tsv import TsvReader
from pycbio.db import sqliteOps

##
# Design notes
#   - SQL is embedded here rather than in separate files to make it easy
#     to only build a subset of tables.
##

verbose = False

def parseArgs():
    desc = """create a sqlite data from a subset of the RefseqGene files.

    Requires RefSeq gene database download from https://ftp.ncbi.nih.gov/gene/DATA/
    The current files are imported:

       gene2refseq.gz
       gene_info.gz
       gene_group.gz
       gene_orthologs.gz
       gene2go.gz

    To download the entire gene database:
       wget -np -nv -nd -r -l 0 -A 'gene*.gz' --unlink -e robots=off https://ftp.ncbi.nih.gov/gene/DATA/

    The size as of 2022-07 is 11G.  These do not need to be uncompressed to load.

    All column names are user from NCBI files, with '.' being replaced by '_'.
    A column RNA_nucleotide_accession is added to gene2refseq with the accession
    without the version.
    """
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("refseqGeneDownloadDir",
                        help="directory with downloaded files")
    parser.add_argument("refseqGeneDb",
                        help="create this database")
    return parser.parse_args()

def baseAccOrNone(accv):
    "drop version if not None"
    return accv.split('.')[0] if accv is not None else None

def getDataFile(datadir, basename):
    "compressed or uncompressed path"
    fpath = osp.join(datadir, basename)
    fpathCmp = fpath + ".gz"
    if osp.exists(fpath):
        return fpath
    elif osp.exists(fpathCmp):
        return fpathCmp
    else:
        raise FileNotFoundError(fpath + " or " + fpathCmp)

def TsvRowReader(tsvReader, nonNullCols):
    for row in tsvReader:
        cols = []
        for colName in tsvReader.columns:
            val = row[colName]
            if (colName not in nonNullCols) and (val in ('-', 'NA')):
                val = None
            cols.append(val)
        yield cols

def tsvLoadToTable(cur, tsvReader, table, tsvFile, *, nonNullCols=frozenset(), extraCols=None, extraColsFunc=None):
    """nonnNllcols indicate which  do not have NULL substitution performed."""
    assert (extraCols is None) == (extraColsFunc is None)
    cnt = 0

    def insert(insertSql, rows):
        cur.execute("BEGIN TRANSACTION")
        cur.executemany(insertSql, rows)
        cur.execute("COMMIT TRANSACTION")
        nonlocal cnt
        cnt += len(rows)
        if verbose:
            print(f"{datetime.now().isoformat()}: {table} inserted {cnt} rows", file=sys.stderr)

    # replace accession.version with accession_version
    dbColNames = [c.replace('.', '_') for c in tsvReader.columns]

    if extraCols is not None:
        dbColNames += list(extraCols)
    # insert in same order:
    insertSql = "INSERT INTO {table} ({colnames}) VALUES ({valbinds});".format(table=table,
                                                                               colnames=",".join(dbColNames),
                                                                               valbinds=",".join(len(dbColNames) * '?'))
    batchSize = 50000
    rows = []
    for row in TsvRowReader(tsvReader, nonNullCols):
        if extraColsFunc is not None:
            extraColsFunc(row)
        rows.append(row)
        if len(rows) >= batchSize:
            insert(insertSql, rows)
            rows = []

    if len(rows) > 0:
        insert(insertSql, rows)

def checkExpectColumns(tsvFile, columns, expectedCols):
    "validate this code matches header, including order."
    columns = tuple(columns)
    if columns != expectedCols:
        raise Exception(f"refseq TSV file '{tsvFile}' columns don't match what is expected in this code, please update the code:\n"
                        f"got: {columns}\nexpect: {expectedCols}")

def buildTable(conn, refseqGeneDownloadDir, table, expectedCols, createSql, indexSql,
               *, nonNullCols=frozenset(), extraCols=None, extraColsFunc=None):
    tsvFile = getDataFile(refseqGeneDownloadDir, table)
    tsvReader = TsvReader(tsvFile)
    checkExpectColumns(tsvFile, tsvReader.columns, expectedCols)
    cur = conn.cursor()
    cur.execute(createSql)
    tsvLoadToTable(cur, tsvReader, table, tsvFile, nonNullCols=nonNullCols, extraCols=extraCols, extraColsFunc=extraColsFunc)
    cur.execute(indexSql)
    cur.close()


###
# gene_info
###
geneInfoExpectedCols = (
    "tax_id", "GeneID", "Symbol", "LocusTag", "Synonyms", "dbXrefs",
    "chromosome", "map_location", "description", "type_of_gene",
    "Symbol_from_nomenclature_authority",
    "Full_name_from_nomenclature_authority", "Nomenclature_status",
    "Other_designations", "Modification_date", "Feature_type"
)

geneInfoCreateSql = """
DROP TABLE IF EXISTS gene_info;
CREATE TABLE gene_info (
    tax_id INT NOT NULL,
    GeneID INT NOT NULL,
    Symbol TEXT,
    LocusTag TEXT,
    Synonyms TEXT,
    dbXrefs TEXT,
    chromosome TEXT,
    map_location TEXT,
    description TEXT,
    type_of_gene TEXT NOT NULL,
    Symbol_from_nomenclature_authority TEXT,
    Full_name_from_nomenclature_authority TEXT,
    Nomenclature_status TEXT,
    Other_designations TEXT,
    Modification_date TEXT NOT NULL,
    Feature_type TEXT
);
"""

geneInfoIndexSql = """
CREATE INDEX gene_info_tax_id ON gene_info (tax_id);
CREATE UNIQUE INDEX gene_info_GeneId ON gene_info (GeneId);
CREATE INDEX gene_info_Symbol ON gene_info (Symbol);
CREATE INDEX gene_info_type_of_gene ON gene_info (type_of_gene);
"""

geneInfoNonNullCols = frozenset(("tax_id", "GeneID", "type_of_gene", "Modification_date"))

def loadGeneInfo(conn, refseqGeneDownloadDir):
    buildTable(conn, refseqGeneDownloadDir, "gene_info", geneInfoExpectedCols, geneInfoCreateSql,
               geneInfoIndexSql, nonNullCols=geneInfoNonNullCols)

###
# gene2refseq
###
gene2refseqExpectedCols = (
    "tax_id", "GeneID", "status", "RNA_nucleotide_accession.version",
    "RNA_nucleotide_gi", "protein_accession.version", "protein_gi",
    "genomic_nucleotide_accession.version", "genomic_nucleotide_gi",
    "start_position_on_the_genomic_accession",
    "end_position_on_the_genomic_accession", "orientation", "assembly",
    "mature_peptide_accession.version", "mature_peptide_gi", "Symbol"
)

# these are derived by dropping version from accessions
gene2refseqDerivedCols = (
    "RNA_nucleotide_accession",
    "protein_accession",
    "genomic_nucleotide_accession",
    "mature_peptide_accession",
)

gene2refseqCreateSql = """
DROP TABLE IF EXISTS gene2refseq;
CREATE TABLE gene2refseq (
    tax_id INT NOT NULL,
    GeneID INT NOT NULL,
    status TEXT,
    RNA_nucleotide_accession_version TEXT,
    RNA_nucleotide_gi TEXT,
    protein_accession_version TEXT,
    protein_gi TEXT,
    genomic_nucleotide_accession_version TEXT,
    genomic_nucleotide_gi TEXT,
    start_position_on_the_genomic_accession TEXT,
    end_position_on_the_genomic_accession TEXT,
    orientation TEXT,
    assembly TEXT,
    mature_peptide_accession_version TEXT,
    mature_peptide_gi TEXT,
    Symbol TEXT NOT NULL,
    -- Derived columns
    RNA_nucleotide_accession TEXT,
    protein_accession TEXT,
    genomic_nucleotide_accession TEXT,
    mature_peptide_accession TEXT,
    FOREIGN KEY(GeneID) REFERENCES gene_info(GeneID)
);
"""

gene2refseqIndexSql = """
CREATE INDEX gene2refseq_tax_id ON gene2refseq (tax_id);
CREATE INDEX gene2refseq_GeneId ON gene2refseq (GeneId);
CREATE INDEX gene2refseq_RNA_nucleotide_accession_version ON gene2refseq (RNA_nucleotide_accession_version);
CREATE INDEX gene2refseq_protein_accession_version ON gene2refseq (protein_accession_version);
CREATE INDEX gene2refseq_genomic_nucleotide_accession_version ON gene2refseq (genomic_nucleotide_accession_version);
CREATE INDEX gene2refseq_mature_peptide_accession_version ON gene2refseq (mature_peptide_accession_version);
CREATE INDEX gene2refseq_Symbol ON gene2refseq (Symbol);
CREATE INDEX gene2refseq_RNA_nucleotide_accession ON gene2refseq (RNA_nucleotide_accession);
CREATE INDEX gene2refseq_protein_accession ON gene2refseq (protein_accession);
CREATE INDEX gene2refseq_genomic_nucleotide_accession ON gene2refseq (genomic_nucleotide_accession);
CREATE INDEX gene2refseq_mature_peptide_accession ON gene2refseq (mature_peptide_accession);
"""

# orientation is '?' if unknown, '-' is strand, not NULL
gene2refseqNonNullCols = frozenset(("tax_id", "GeneID", "Symbol", "orientation"))

def loadGene2refseq(conn, refseqGeneDownloadDir):
    def _addDerived(row):
        row.extend([baseAccOrNone(row[3]),    # RNA_nucleotide_accession.version
                    baseAccOrNone(row[5]),    # protein_accession.version
                    baseAccOrNone(row[7]),    # genomic_nucleotide_accession.version
                    baseAccOrNone(row[13])])  # mature_peptide_accession.version

    buildTable(conn, refseqGeneDownloadDir, "gene2refseq",
               gene2refseqExpectedCols, gene2refseqCreateSql,
               gene2refseqIndexSql, nonNullCols=gene2refseqNonNullCols,
               extraCols=gene2refseqDerivedCols, extraColsFunc=_addDerived)

###
# gene_group and gene_orthologs
###
geneAssocExpectedCols = (
    "tax_id", "GeneID", "relationship", "Other_tax_id", "Other_GeneID"
)
geneAssocCreateSql = """
DROP TABLE IF EXISTS {table};
CREATE TABLE {table} (
    tax_id INT NOT NULL,
    GeneID INT NOT NULL,
    relationship TEXT NOT NULL,
    Other_tax_id INT NOT NULL,
    Other_GeneID INT NOT NULL,
    FOREIGN KEY(GeneID) REFERENCES gene_info(GeneID),
    FOREIGN KEY(Other_GeneID) REFERENCES gene_info(GeneID)
);
"""

geneAssocIndexSql = """
CREATE INDEX {table}_tax_id ON {table} (tax_id);
CREATE INDEX {table}_GeneId ON {table} (GeneId);
CREATE INDEX {table}_Other_tax_id ON {table} (Other_tax_id);
CREATE INDEX {table}_Other_GeneId ON {table} (Other_GeneId);
"""
geneAssocNonNullCols = geneAssocExpectedCols

def loadGeneAssocTypeTable(conn, refseqGeneDownloadDir, table):
    buildTable(conn, refseqGeneDownloadDir, table, geneAssocExpectedCols,
               geneAssocCreateSql.format(table=table), geneAssocIndexSql.format(table=table),
               nonNullCols=geneAssocNonNullCols)

###
# gene2go
###
gene2goExpectedCols = (
    "tax_id", "GeneID", "GO_ID", "Evidence", "Qualifier", "GO_term", "PubMed", "Category"
)

gene2goCreateSql = """
DROP TABLE IF EXISTS gene2go;
CREATE TABLE gene2go (
    tax_id INT NOT NULL,
    GeneID INT NOT NULL,
    GO_ID TEXT NOT NULL,
    Evidence TEXT NOT NULL,
    Qualifier TEXT NOT NULL,
    GO_term TEXT NOT NULL,
    PubMed TEXT,
    Category TEXT NOT NULL,
    FOREIGN KEY(GeneID) REFERENCES gene_info(GeneID)
);
"""
gene2goIndexSql = """
CREATE INDEX gene2go_tax_id ON gene2go (tax_id);
CREATE INDEX gene2go_GeneId ON gene2go (GeneId);
CREATE INDEX gene2go_GO_ID ON gene2go (GO_ID);
CREATE INDEX gene2go_GO_term ON gene2go (GO_term);
"""

def loadGene2go(conn, refseqGeneDownloadDir):
    buildTable(conn, refseqGeneDownloadDir, "gene2go",
               gene2goExpectedCols, gene2goCreateSql,
               gene2goIndexSql)

##
# main
##
def buildRefseqGeneDb(refseqGeneDownloadDir, refseqGeneDb):
    conn = sqliteOps.connect(refseqGeneDb, create=True)
    sqliteOps.setFastLoadPragmas(conn)
    loadGene2refseq(conn, refseqGeneDownloadDir)
    loadGeneInfo(conn, refseqGeneDownloadDir)
    loadGeneAssocTypeTable(conn, refseqGeneDownloadDir, "gene_group")
    loadGeneAssocTypeTable(conn, refseqGeneDownloadDir, "gene_orthologs")
    loadGene2go(conn, refseqGeneDownloadDir)
    conn.close()

def main(opts):
    buildRefseqGeneDb(opts.refseqGeneDownloadDir, opts.refseqGeneDb)

main(parseArgs())
