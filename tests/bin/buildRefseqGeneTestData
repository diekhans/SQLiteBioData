#!/usr/bin/env python3

import sys
from os import path as osp
import argparse
from pycbio.sys import fileOps
from pycbio.db import sqliteOps
from pycbio.tsv import TsvReader

sqllenReLib = "/cluster/home/markd/opt/current/x86_64/lib/sqlean-0.9.1/re.so"

def parseArgs():
    desc = """generate test cases from a full refseqGeneDb
    """
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("refseqGeneDb",
                        help="full database")
    parser.add_argument("refseqCasesTsv",
                        help="contains either GeneID and/or accession columns")
    parser.add_argument("outdir",
                        help="directory for output")
    return parser.parse_args()

createTmpTblSql = """
CREATE TEMP TABLE testGeneIds (
    GeneID INT
);
CREATE INDEX testGeneIds_GeneID ON testGeneIds (GeneID);
"""

loadGeneIdsSql = """
INSERT INTO testGeneIds (GeneID) VALUES (?);
"""

# This was used to generate original set of test case, however
# they were move to a file to allow added specific ones.  This remains
# here for documentation.
getTaxonCaseSql = r"""
-- symbol without synonym match
INSERT INTO testGeneIds
   SELECT GeneID FROM gene_info WHERE (tax_id = :tax_id) AND
       ((Symbol LIKE "znf%") AND
        (Synonyms NOT REGEXP "(\||^)[zZ][nN][fF]")) LIMIT 50;

-- synonym without symbol match
INSERT INTO testGeneIds
   SELECT GeneID FROM gene_info WHERE (tax_id = :tax_id) AND
       ((Symbol NOT LIKE "znf%") AND
        (Synonyms REGEXP "(\||^)[zZ][nN][fF]")) LIMIT 25;

-- some other stuff, don't get NEWENTRY stuff
INSERT INTO testGeneIds
   SELECT GeneID FROM gene_info WHERE (tax_id = :tax_id) AND
       (Symbol != "NEWENTRY") AND
       ((Symbol NOT LIKE "znf%")) AND
        (Synonyms NOT REGEXP "(\||^)[zZ][nN][fF]") LIMIT 10;
"""

getHomologSql = """
-- make sure we have all paralogs and orthologs in table
INSERT INTO testGeneIds
    SELECT Other_GeneId FROM gene_group WHERE GeneId IN (select GeneID FROM testGeneIds);
INSERT INTO testGeneIds
    SELECT GeneId FROM gene_group WHERE Other_GeneId IN (select GeneID FROM testGeneIds);
"""


def loadRefseqCasesTsv(refseqCasesTsv):
    # tuple per row
    typeMap = {
        'tax_id': int,
        'GeneID': int
    }
    refseqCases = [r for r in TsvReader(refseqCasesTsv, typeMap=typeMap)]
    if len(refseqCases) == 0:
        raise Exception(f"no data found in '{refseqCasesTsv}'")
    if ("GeneID" not in refseqCases[0]._columns_) and ("accession" not in refseqCases[0]._columns_):
        raise Exception(f"TSV must have 'GeneId' or 'accession' columns, or both: '{refseqCasesTsv}'")
    return refseqCases

def accDropVersion(acc):
    return acc.split('.')[0]

def queryGeneId(cur, acc):
    sql = "SELECT distinct GeneID FROM gene2refseq WHERE (RNA_nucleotide_accession = ?)"
    cur.execute(sql, (accDropVersion(acc),))
    # should only get one back, but consume cursor
    geneId = None
    for row in cur:
        geneId = row[0]
    if geneId is None:
        print(f"Warning: '{acc}' not found in database", file=sys.stderr)
    return geneId

def getGeneIdsForAccessions(cur, refseqCases):
    geneIds = set()
    for refseqCase in refseqCases:
        geneId = queryGeneId(cur, refseqCase.accession)
        if geneId is not None:
            geneIds.add(geneId)
    return geneIds

def getGeneIds(cur, refseqCases):
    if "GeneID" in refseqCases[0]._columns_:
        return frozenset([r.GeneID for r in refseqCases])
    else:
        return getGeneIdsForAccessions(cur, refseqCases)

def createGeneIdTable(cur, geneIds):
    cur.execute(createTmpTblSql).fetchall()
    # each entry must be a row
    cur.executemany(loadGeneIdsSql, [(g,) for g in geneIds]).fetchall()
    cur.execute(getHomologSql).fetchall()

def writeTsvHeader(cur, table, fh):
    "use this rather than cursor.description so can handle empty result"
    cur.execute(f"PRAGMA table_info({table})")
    cols = [r[1] for r in cur]
    fh.write('#')
    fileOps.prRow(fh, cols)

def createGeneDataFile(cur, table, sql, fname):
    with open(fname, 'w') as fh:
        writeTsvHeader(cur, table, fh)
        cur.execute(sql)
        for row in cur:
            fileOps.prRow(fh, row)

def createGeneDataFiles(cur, outdir):
    createGeneDataFile(cur, "gene2refseq",
                       "SELECT * FROM gene2refseq WHERE GeneID in testGeneIds;",
                       osp.join(outdir, "gene2refseq"))
    createGeneDataFile(cur, "gene_info",
                       "SELECT * FROM gene_info WHERE GeneID in testGeneIds;",
                       osp.join(outdir, "gene_info"))
    createGeneDataFile(cur, "gene_group",
                       "SELECT * FROM gene_group WHERE (GeneID IN testGeneIds) or (Other_GeneId IN testGeneIds);",
                       osp.join(outdir, "gene_group"))
    createGeneDataFile(cur, "gene_orthologs",
                       "SELECT * FROM gene_orthologs WHERE (GeneID IN testGeneIds) or (Other_GeneId IN testGeneIds);",
                       osp.join(outdir, "gene_orthologs"))

def buildRefseqGeneTestData(opts):
    refseqCases = loadRefseqCasesTsv(opts.refseqCasesTsv)
    conn = sqliteOps.connect(opts.refseqGeneDb, rowFactory=None)
    sqliteOps.loadExtension(conn, sqllenReLib)
    cur = conn.cursor()

    geneIds = getGeneIds(cur, refseqCases)
    createGeneIdTable(cur, geneIds)
    fileOps.ensureDir(opts.outdir)
    createGeneDataFiles(cur, opts.outdir)
    conn.close()

buildRefseqGeneTestData(parseArgs())
